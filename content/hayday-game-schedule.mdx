---
title: Cracking the Scheduling Code in Hay Day
publishedAt: 2024-04-23
summary: A deep dive into the scheduling problem in the Hay Day game.
---

It's has beed a long time since my last post. I have been busy with my work. I was researching the scheduling problem in the Hay Day game for a while. And now is the good time to share the result with you.

## What is Hay Day?


Hay Day is a popular mobile game created by Supercell in 2012. It is a farming simulator where you can plant crops and trees, raise animals, sell products, compete in derbies, and so much more. Hay Day is a freemium game so all features of the game are open to players who choose not to buy in-app-purchases.

<YouTubeEmbed videoId="mSev84nF1HA"/>

In Hay Day, your main job is to make products based on the orders that you receive from the customers. When you complete the order, you will get coins and experience points. The orders are generated randomly and you can choose to accept or decline them. The orders are combine of products that you can make in the game.

<Image src="/images/hayday-game-schedule/hayday-orders.png" width="800" height="700" alt="orders" />

To make products in the game, you need two main resources: goods (or product) and machine. Each goods has a production time, a machine that can produce it and goods that are required to make it. For example, to make a _chicken feed_, you need _2 wheat_ and _1 corn_. The production time of a _chicken feed_ is _5 minutes_ and it can be made in the _feed mill_. And 

For a deep dive into the game, you can check out the [Hay Day Wiki](https://hayday.fandom.com/wiki/Hay_Day_Wiki). 

<Image src="/images/hayday-game-schedule/chart-dark.png" width="1100" height="800" className="hidden dark:block" alt="chart" />
<Image src="/images/hayday-game-schedule/chart-light.png" className="dark:hidden block" width="1100" height="800" alt="chart" />

## The problem

Hay Day is a really easy game, at least when I started playing. Wheat is planted, gathered, and sold. Alternately, you may use wheat to produce and sell bread. However, as the game progresses, you will acquire additional machines, goods, and orders. 


<HaydayGameSchedule.Chart/>

As you can see, just in level 20 of the game, we have 40 goods and 10 machines. The permutation of the goods and machines is huge. At this point, the scheduling issue arises.

So what do we want to solve here? Let clarify the problem:

- An order is a set of goods that need to be made.
- A machine can only produce one good at a time.
- A machine can only produce a good if it has all the required goods.
- A good can only be produced on a specific machine.

Our target:

- Given a set of orders, find a schedule that maximize the **makespan** of the orders.
- The makespan is the time between the start of the first order and the end of the last order.

A simple scheduling to make a order with two egg will look like this:

<Image src="/images/hayday-game-schedule/machine_schedule.png" width="1200" height="400" alt="scheduling" />

But in reality, the scheduling is more complex. Here is the image showing the scheduling of 2 orders with 4 goods:

<Image src="/images/hayday-game-schedule/complex_machine_schedule.png" width="1200" height="400" alt="complex" />


## First attempt

So how can we solve this problem? 

The first thing that comes to my mind is [genetic algorithm](https://en.wikipedia.org/wiki/Genetic_algorithm). 

The genetic algorithm is a search heuristic inspired by [Darwin's theory of evolution](https://en.wikipedia.org/wiki/Darwinism). This algorithm borrows the following concepts from natural selection:

- Each individual (solution) has an associated fitness score
- Individuals with high fitness scores are selected for reproduction
- Chosen individuals reproduce to create offspring with the characteristics of both parents
- Some offspring would have random mutations applied to them

The idea is that if the parents have high fitness, the offspring would have high fitness as well.

This entire process of **selection**, **reproduction** (more commonly known as crossover), and **mutation** will repeat many times. At the end, only the fittest individuals will remain. These fittest individuals represent the solutions to our problem.

<Callout emoji="ðŸ’¡">
Only the fittest will survive - Charles Darwin
</Callout>

<Image src="/images/hayday-game-schedule/naturalselection.jpg" width="2000" height="1000" alt="complex" />


### Encoding and decoding

Encoding and decoding are the most important parts of the genetic algorithm. The encoding is the way we represent the solution in the genetic algorithm. The decoding is the way we convert the encoded solution to the real solution. 

In our case, the encoding solution is a $ 2 \times n $ matrix where $ n $ is the number of task (produce good task) we need to schedule. The first row is the machine that will produce the good and the second row is the id of the good that will be produced. The order in the second row is the order of what task will be produced first. If task $j$ is required to produce task $i$, the index of task $j$ in the second row must be less than the index of task $i$.

For example, given a 5 tasks, 3 machine to schedule:

- Task 1: can be produced by machine 1, required Task 2 and Task 3
- Task 2: can be produced by machine 2,3, required Task 4
- Task 3: can be produced by machine 1, required Task 5
- Task 4: can be produced by machine 1,3
- Task 5: can be produced by machine 3

A valid solution can be encoding as:

<center>
$
\begin{bmatrix}
1 & 3 & 2 & 1 & 1 \\
4 & 5 & 2 & 3 & 1
\end{bmatrix}
$
</center>

Meaning:

- Task 4 will be produced by machine 1, Task 5 will be produced by machine 3. They can be produced at the same time.
- Task 2 will be produced by machine 2 after Task 4 is done.
- Task 3 will be produced by machine 1 after Task 5 is done.
- Task 1 will be produced by machine 1 after Task 2 and Task 3 are done.

To decode the solution, we will create a timeline of the machine and the task that will be produced by the machine at that time. We loop through the solution matrix and add the task to the timeline from left to right. At each step, we check the time with the required tasks of the task that will be produced and the time of the machine that will produce the task. 

Here is the visualization of the decoding solution:

<Image src="/images/hayday-game-schedule/visual.gif" width="600" height="300" alt="visual" />

### Fitness function

The fitness function is the function that we use to evaluate the solution. In our case, the fitness function is the makespan of the solution. This function take a important role in the genetic algorithm. The better the fitness function, the better the solution. It's may affect how the solution is formed.

If we want to finish the orders as soon as possible, we can use the makespan as the fitness function. If we want to finish the orders with the least number of machines, we can use the number of machines as the fitness function. Or we want to finish all the order as soon as possible, we can use the sum of the makespan of all the orders as the fitness function.

In this experiment, I use 2 fitness functions: makespan and sum of makespan of all the orders.

### Selection

Fitness Proportionate Selection is one of the most popular ways of parent selection. In this every individual can become a parent with a probability which is proportional to its fitness. Therefore, fitter individuals have a higher chance of mating and propagating their features to the next generation. Therefore, such a selection strategy applies a selection pressure to the more fit individuals in the population, evolving better individuals over time.

Consider a circular wheel. The wheel is divided into n pies, where n is the number of individuals in the population. Each individual gets a portion of the circle which is proportional to its fitness value.

In a roulette wheel selection, the circular wheel is divided as described before. A fixed point is chosen on the wheel circumference as shown and the wheel is rotated. The region of the wheel which comes in front of the fixed point is chosen as the parent. For the second parent, the same process is repeated.

<Image src="/images/hayday-game-schedule/Roulette-wheel-selection-method.png" width="400" height="400" alt="wheel" />

### Crossover

The crossover for this problem is a little bit complex. According to [this paper](https://www.researchgate.net/publication/281545095_SOLVING_JOB_SHOP_SCHEDULING_PROBLEM_WITH_GENETIC_ALGORITHM), they have used order crossover for operations shuffling between two parent schedules. Whereas, uniform crossover operator is used for shuffling of machines assignment to operations

#### Order crossover

Order crossover operator is a specific type of crossover that is particularly useful when dealing with permutation-based problems, such as the Traveling Salesman Problem (TSP), scheduling problems, or any problem where the solution consists of an ordered sequence of elements.

Here's how the order crossover operator works:

- Two parent solutions are selected from the population.
- A substring (a sequence of consecutive elements) is randomly selected from one of the parents.
- The offspring solution is created by copying the selected substring from the first parent into the same positions in the offspring.
- The remaining positions in the offspring are filled with the elements from the second parent, in the order in which they appear, skipping the elements that were already copied from the first parent.

Here's an example to illustrate the process:


Suppose we have two parent solutions represented as sequences of numbers:

Parent 1: $ [1, 2, 3, 4, 5, 6, 7, 8] $

Parent 2: $[5, 3, 1, 7, 2, 8, 6, 4]$

Let's assume we randomly select the substring $[3, 4, 5]$ from Parent 1.

Step 1: Copy the substring $[3, 4, 5]$ into the offspring:

Offspring: $[\_,\_, 3, 4, 5, \_, \_, \_]$

Step 2: Fill in the remaining positions with the elements from Parent 2, skipping the elements already present in the offspring (3, 4, 5):

Offspring: $[5, 1, 3, 4, 5, 7, 2, 8]$


## Resource

- [Hay Day Good list](https://hayday.fandom.com/wiki/Goods_List)
- [Hay Day Production Buildings List](https://hayday.fandom.com/wiki/Production_Buildings_List)
- [Google's OR-Tools Code for Flexible Job Shop Scheduling](https://github.com/google/or-tools/blob/stable/examples/python/flexible_job_shop_sat.py)